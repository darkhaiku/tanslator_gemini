<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubTranslate AI Pro | v2.5</title>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root { --primary: #2563eb; --success: #059669; --bg: #f8fafc; --error: #dc2626; }
        body { font-family: 'Vazirmatn', sans-serif; background-color: var(--bg); margin: 0; padding: 20px; direction: rtl; }
        .container { max-width: 900px; margin: 0 auto; background: white; padding: 30px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        .header { text-align: center; border-bottom: 2px solid #f1f5f9; margin-bottom: 25px; padding-bottom: 15px; }
        .grid-config { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .input-box { display: flex; flex-direction: column; gap: 5px; }
        label { font-weight: bold; font-size: 0.85rem; color: #475569; }
        input { padding: 12px; border: 1px solid #e2e8f0; border-radius: 10px; outline: none; }
        input:focus { border-color: var(--primary); }
        .upload-area { border: 2px dashed #cbd5e1; padding: 25px; text-align: center; border-radius: 15px; cursor: pointer; background: #fff; transition: 0.3s; }
        .upload-area:hover { border-color: var(--primary); background: #f0f7ff; }
        #chunks-list { margin-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        .chunk-item { display: flex; align-items: center; justify-content: space-between; background: #f1f5f9; padding: 15px; border-radius: 12px; border: 1px solid #e2e8f0; }
        .btn { padding: 10px 18px; border-radius: 8px; border: none; cursor: pointer; font-weight: bold; font-family: inherit; transition: 0.3s; }
        .btn-translate { background: var(--primary); color: white; }
        .btn-download { background: var(--success); color: white; }
        .btn-merge { background: #000; color: white; width: 100%; margin-top: 20px; font-size: 1rem; }
        .badge { font-size: 0.75rem; padding: 4px 10px; border-radius: 10px; background: #cbd5e1; margin-right: 10px; }
        .status-done { background: #dcfce7; color: #166534; }
        .status-error { background: #fee2e2; color: #991b1b; }
        .loader { width: 16px; height: 16px; border: 2px solid white; border-top-color: transparent; border-radius: 50%; display: none; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>Ù…ØªØ±Ø¬Ù… ÙÙˆÙ‚ Ù‡ÙˆØ´Ù…Ù†Ø¯ Gemini 2.5 ğŸ’</h1>
        <p>ØªØ±Ø¬Ù…Ù‡ Ø³Ù„ÛŒØ³ Ùˆ ØªØ®ØµØµÛŒ Ø¨Ø§ Ø­ÙØ¸ Ú©Ø§Ù…Ù„ Ø³Ø§Ø®ØªØ§Ø± ÙØ§ÛŒÙ„</p>
    </div>

    <div class="grid-config">
        <div class="input-box">
            <label>Gemini API Key:</label>
            <input type="password" id="apiKey" placeholder="AIzaSy...">
        </div>
        <div class="input-box">
            <label>Ù…ÙˆØ¶ÙˆØ¹ Ùˆ Ù„Ø­Ù† (Ù…Ø«Ù„Ø§Ù‹: Ù…Ø³ØªÙ†Ø¯ Ø¹Ù„Ù…ÛŒØŒ ÙÛŒÙ„Ù… Ú©Ù…Ø¯ÛŒ):</label>
            <input type="text" id="context" placeholder="Ù…Ø«Ù„Ø§Ù‹: Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù†ÙˆÛŒØ³ÛŒ Ù¾Ø§ÛŒØªÙˆÙ†">
        </div>
    </div>

    <div class="upload-area" id="dropZone">
        <strong id="uploadText">ÙØ§ÛŒÙ„ SRT ÛŒØ§ VTT Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯</strong>
        <input type="file" id="fileInput" accept=".srt,.vtt" hidden>
    </div>

    <div id="chunks-list"></div>

    <button id="mergeBtn" class="btn btn-merge" style="display:none;">Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ Ù†Ù‡Ø§ÛŒÛŒ ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡</button>
</div>

<script>
    let chunks = [];
    const MODEL_ID = "gemini-2.5-flash";

    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');

    dropZone.onclick = () => fileInput.click();
    fileInput.onchange = (e) => handleFile(e.target.files[0]);

    function handleFile(file) {
        if (!file) return;
        document.getElementById('uploadText').innerText = file.name;
        const reader = new FileReader();
        reader.onload = (e) => processSubtitles(e.target.result);
        reader.readAsText(file);
    }

    function processSubtitles(content) {
        // Ø¬Ø¯Ø§ Ú©Ø±Ø¯Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¨Ù„Ø§Ú©â€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø²ÛŒØ±Ù†ÙˆÛŒØ³ (Ø¯Ùˆ Ø®Ø· Ø®Ø§Ù„ÛŒ Ù…ØªÙˆØ§Ù„ÛŒ ÛŒØ§ ØªÚ© Ø®Ø· Ø®Ø§Ù„ÛŒ)
        const blocks = content.trim().split(/\n\s*\n/);
        chunks = [];
        const chunkSize = 40; // Ú©Ø§Ù‡Ø´ Ø­Ø¬Ù… Ø¨Ø±Ø§ÛŒ Ø¯Ù‚Øª Ø¨ÛŒØ´ØªØ± Ùˆ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù‚Ø·Ø¹ Ø´Ø¯Ù† ØªØ±Ø¬Ù…Ù‡

        for (let i = 0; i < blocks.length; i += chunkSize) {
            const chunkBlocks = blocks.slice(i, i + chunkSize);
            chunks.push({
                id: (i / chunkSize) + 1,
                originalBlocks: chunkBlocks,
                text: chunkBlocks.join('\n\n'),
                translated: null,
                blockCount: chunkBlocks.length
            });
        }
        render();
    }

    function render() {
        const list = document.getElementById('chunks-list');
        list.innerHTML = chunks.map(c => `
            <div class="chunk-item">
                <div>
                    <strong>Ù‚Ø·Ø¹Ù‡ ${c.id}</strong>
                    <span class="badge">ØªØ¹Ø¯Ø§Ø¯ Ø¨Ù„Ø§Ú©: ${c.blockCount}</span>
                    <span id="badge-${c.id}" class="badge">Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±</span>
                </div>
                <div>
                    <button class="btn btn-translate" id="btn-${c.id}" onclick="translateChunk(${c.id})">
                        <span class="loader" id="loader-${c.id}"></span>
                        Ø´Ø±ÙˆØ¹ ØªØ±Ø¬Ù…Ù‡
                    </button>
                </div>
            </div>
        `).join('');
    }

    async function translateChunk(id) {
        const apiKey = document.getElementById('apiKey').value;
        const context = document.getElementById('context').value || "Ø¹Ù…ÙˆÙ…ÛŒ";
        const chunk = chunks.find(c => c.id === id);
        
        if (!apiKey) return alert("Ù„Ø·ÙØ§ API Key Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.");

        const btn = document.getElementById(`btn-${id}`);
        const loader = document.getElementById(`loader-${id}`);
        const badge = document.getElementById(`badge-${id}`);

        btn.disabled = true;
        loader.style.display = "inline-block";

        const prompt = `
            You are a world-class professional translator and linguistic expert. 
            Translate the following subtitle blocks into Persian (Farsi).
            Target Audience: Persian speakers who enjoy natural, idiomatic, and fluent language.
            Context of content: ${context}.

            RULES:
            1. DO NOT change, translate, or modify timecodes or block numbers. (e.g., "00:00:01,000 --> 00:00:04,000" must remain identical).
            2. TONE: Avoid "Google Translate" style. Do not use literal word-for-word translation. 
            3. FLUENCY: Use natural Persian sentence structures. For example, instead of "Ø¢Ù† ÛŒÚ© Ø±ÙˆØ² Ø®ÙˆØ¨ Ø¨ÙˆØ¯" use "Ø±ÙˆØ² Ø®ÙˆØ¨ÛŒ Ø¨ÙˆØ¯".
            4. COMPLETENESS: You MUST translate every single block provided. If you receive 40 blocks, you must return 40 blocks. 
            5. No explanations. Return only the raw subtitle format.
            6. If the context is "${context}", use its specific terminology like a pro in that field.

            SUBTITLE BLOCKS:
            ${chunk.text}
        `;

        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_ID}:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });

            const data = await response.json();
            if (data.error) throw new Error(data.error.message);

            const translatedText = data.candidates[0].content.parts[0].text;
            
            // Ù…Ù†Ø·Ù‚ ØµØ­Øªâ€ŒØ³Ù†Ø¬ÛŒ (Validation)
            const translatedBlocks = translatedText.trim().split(/\n\s*\n/);
            
            if (translatedBlocks.length < chunk.blockCount) {
                console.warn(`Mismatch in chunk ${id}: Expected ${chunk.blockCount}, got ${translatedBlocks.length}`);
                // ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø§ØµÙ„Ø§Ø­: Ø§Ú¯Ø± ØªØ¹Ø¯Ø§Ø¯ Ú©Ù… Ø¨ÙˆØ¯ØŒ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø§Ø·Ù„Ø§Ø¹ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒÙ…
                badge.innerText = "Ù†Ù‚Øµ Ø¯Ø± ØªØ¹Ø¯Ø§Ø¯ Ø³Ø·Ø±Ù‡Ø§!";
                badge.className = "badge status-error";
            } else {
                badge.innerText = "ØªØ±Ø¬Ù…Ù‡ Ù…ÙˆÙÙ‚";
                badge.className = "badge status-done";
            }

            chunk.translated = translatedText;
            btn.innerText = "ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯";
            btn.className = "btn btn-download";
            btn.onclick = () => saveFile(chunk.translated, `part_${id}.srt`);
            
            checkAll();
        } catch (err) {
            alert("Ø®Ø·Ø§: " + err.message);
            btn.disabled = false;
        } finally {
            loader.style.display = "none";
        }
    }

    function checkAll() {
        if (chunks.every(c => c.translated)) {
            document.getElementById('mergeBtn').style.display = "block";
        }
    }

    document.getElementById('mergeBtn').onclick = () => {
        const final = chunks.map(c => c.translated).join('\n\n');
        saveFile(final, "final_translated.srt");
    };

    function saveFile(str, name) {
        const blob = new Blob([str], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = name;
        a.click();
    }
</script>
</body>
</html>
